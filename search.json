[{"title":"IDEA","url":"/2021/12/23/IDEA/","content":"IDE集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。编程开发软件将编辑、编译、调试等功能集成在一个桌面环境中,这样就大大方便了用户。优点节省时间和精力。IDE的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当IDE提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。管理开发工作。首先，IDE提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。缺点学习曲线问题。IDE基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。初学者的困难。对初学者来说，使用IDE来学习开发有相当的难度，不适合学习一种新语言时使用。无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。\nJetBrains公司JetBrains公司介绍：JetBrains是一家捷克的软件开发公司，该公司位于捷克的布拉格，并在俄罗斯的圣彼得堡及美国麻州波士顿都设有办公室，该公司最为人所熟知的产品是Java编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。公司旗下还有其它产品，比如：WebStorm: 用于开发JavaScript、HTML5、 CS3等前端技术;PyCharm: 用于开发python（python语言热度排行榜排名第一，在人工智能大数据领域应用）PhpStorm: 用于开发PHPRubyMine: 用于开发Ruby/RailsAppCode: 用于开发Objective - C/Swift,替换xcode的CLion: 用于开发C/C++DataGrip: 用于开发数据库和SQLRider: 用于开发.NETGoLand: 用于开发Go（区块链主流开发语言就是Go语言）官网：https://www.jetbrains.com/\nIDEAIDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境IDE(Integrated Development Environment)，也可用于其他语言。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。IDEA的支持IDEA的优势（相对于Eclipse）1.强大的整合能力。比如: Git、 Maven、 Spring 等2.提示功能的快速、便捷3.提示功能的范围广4.好用的快捷键和代码模板5.精准搜索\nIDEA和Eclipse的区别在Eclipse中我们有Workspace (工作空间)和Project (工程)的概念，在IDEA中只有Project (工程)和Module (模块)的概念。这里的对应关系为:IDEA官网说明:Eclipse中 workspace 相当于 IDEA中的ProjectEclipse中   Project     相当于 IDEA中的Module在IntelliJ IDEA中Project(工程) 是最顶级的级别，次级别是Module(模块)。一个Project下可以有多个Module。从Eclipse 转过来的人总是下意识地要在同一个窗口管理n个项目，这在Intellij IDEA是无法做到的。Intellij IDEA提供的解决方案是打开多个项目实例，即打开多个项目窗口。即:一个Project 打开一个Window窗口。IDEA这样设置的原因：目前主流的大型项目都是分布式部署的，结构都是类似这种多Module的。这类项目一般是这样划分的，比如: 积分模块、任务模块、活动模块等等，模块之间彼此可以相互依赖。这些Module之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。\nIDEA常用快捷键1.创建内容：alt+insert2.main方法：psvm3.输出语句：sout4.复制行：ctrl+d5.删除行：ctrl+y6.代码向上/下移动：Ctrl + Shift + Up / Down7.搜索类：  ctrl+n8.生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode,equals,toString）9.百能快捷键 : alt + Enter （导包，生成变量等）10.单行注释或多行注释 ：  Ctrl + / 或 Ctrl + Shift + /11.重命名 shift+f612.for循环  直接 ：fori   回车即可13.代码块包围：try-catch,if,while等  ctrl+alt+t14.显示代码结构  : alt + 715.显示导航栏： alt +116.撤回：ctrl+z17.缩进：tab  取消缩进： shift+tab\n","categories":["Java"],"tags":["IDEA"]},{"title":"Java介绍","url":"/2021/12/22/Java-%E5%8F%91%E5%B1%95%E5%8F%B2/","content":"前言：此篇文章包括Java的发展史、Java结构和JAVA的特性优势，发展史有过了解即可，Java的结构和特性优势要搞明白，为什么Java一直处于计算机语言的主流地位，Java与其他语言的区别在哪，这对我们以后的项目也有很大的好处。\nJava简史Java发明人James  Gosling\nSUN公司SUN公司美国SUN(Stanford University Network)公司在中国大陆的正式中文名为“太阳计算机系统（中国）有限公司”在台湾中文名为“升 阳电脑公司”。\nJava发明的缘由Java为什么被发明Green项目。应用环境：像电视盒这样的消费类电子产品要求： 语言本身是中立的，也就是跨平台        1996年Java第一次发布就引起了人们的极大兴趣。关注Java的人士不仅限于计算机出版界，  还有诸如《纽约时报》《华盛顿邮报》《商业周刊》这样的主流媒体。Java 是第一种也是唯一种在National Public Radio上占用了10分钟时间来进行介绍的程序设计语言，并且还得到了$100000000的风险投资基金。这些基金全部用来支持用这种特别的计算机语言开发的产品。重温那些令人兴奋的日子是很有意思的。我们将简要地介绍一下Java语言的发展历史：        Java的历史要追溯到1991年，由Patrick Naughton 及其伙伴James Gosling (一个全能的计算机奇才)带领的Sun公同的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小且能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器(CPU)，因此这种语言的关键是不能与任何特定的体系结构捆绑在一起。这个项目被命名为”Green”。        所有就要求有这样的一种代码： 代码短小、紧凑且与平台无关。但是，Sun公司的人都有UNIX的应用背景。因此，所开发的语言以C++为基础。 是Gosling率先创造了这个语言，把这种语言称为“Oak”(这么起名的原因大概是因为他非常喜欢自己办公室外的橡树)。Sun 公司的人后来发现Oak是一种已有的计算机语言的名字，于是，将其改名为Java。\n历程经历阶段1991年，James Gosling在SUN公司的工程师小组想要设计这样一种小型计算机语言。该语言主要用于像电视盒这样的消费类电子产品。另外，由于不同的厂商选择不同的CPU和操作系统，因此，要求该语言不能和特定的体系结构绑在一起，要求语言本身是中立的，也就是跨平台的。所以，将这个语言命名为“Green”，类似于绿色软件的意思。后来，改名为Oak，橡树的意思。改名后发现已经有一种语言叫这个名字了，再改名叫Java。Java语言发展到今天经历了一系列的过程：–1991年，SUN公司的Green项目，Oak–1995年，推出Java测试版–1996年，JDK1.0–1997年，JDK1.1–1998年，JDK1.2，大大改进了早期版本缺陷，是一个革命性的版本，更名为Java2。–2004年，J2SE 5.0 (1.5.0)  Tiger老虎 成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0–2005年，Java的各种版本已经更名，以取消其中的数字”2”： J2ME更名为Java ME， J2SE更名为Java SE， J2EE更名为Java EE；–2006年，J2SE 6.0 (1.6.0)  Mustang野马–2009年，甲骨文(oracle)收购SUN，交易高达价格74亿–2011年，JavaSE7.0   Dolphin海豚–2014年，JavaSE8.0–2017年，JAVA 9.0–2018年3月，JAVA 10–2018年9月，JAVA 11–2019年3月，JAVA 12–2019年9月，JAVA 13–2020年3月，JAVA 14现在SUN公司已经被oracle公司收购，目前每半年更新一次java的版本。但是，企业中的主流仍然以7和8为主。对于初学者，应该以企业主流应用版本为核心进行学习，没有必须在此处追求最新版本。\n不同版本JDK说明JDK说明JDK Version 1.1   于1997-02-19发行。   引入的新特性包括：   引入JDBC（Java Database Connectivity）；   支持内部类；   引入Java Bean；   引入RMI（Remote Method Invocation）；   引入反射（仅用于内省）。J2SE Version 1.2   开发代号为Playground（操场），于1998-12-08发行。   引入的新特性包括：   引入集合（Collection）框架；   对字符串常量做内存映射；   引入JIT（Just In Time）编译器；   引入对打包的Java文件进行数字签名；   引入控制授权访问系统资源的策略工具；   引入JFC（Java Foundation Classes），包括Swing 1.0、拖放和Java 2D类库；   引入Java 插件；   在JDBC中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；   在Applet中添加声音支持。J2SE Version 1.3  开发代号为Kestrel（红隼），于2000-05-08发行。   引入的新特性包括：   引入Java Sound API；   jar文件索引；   对Java的各个方面都做了大量优化和增强。J2SE Version 1.4   开发代号为Merlin（隼），于2004-02-06发行（首次在JCP下发行）。   引入的新特性包括:   XML处理；   Java打印服务；   引入Logging API；   引入Java Web Start；   引入JDBC 3.0 API；   引入断言；   引入Preferences API；   引入链式异常处理；   支持IPv6；   支持正则表达式；   引入Image I/O slot machine API。Java Version SE 5.0   开发代号为Tiger（老虎），于2004-09-30发行。   引入的新特性包括:   引入泛型；   增强循环，可以使用迭代方式；   自动装箱与自动拆箱；   类型安全的枚举；   可变参数；   静态引入；   元数据（注解）；   引入Instrumentation。Java Version SE 6   开发代号为Mustang（野马），于2006-12-11发行。   引入的新特性包括：   支持脚本语言；   引入JDBC 4.0 API；   引入Java Compiler API；   可插拔注解；   增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access   Protocol)的支持；   继承Web Services；   做了很多优化。Java Version SE 7   开发代号是Dolphin（海豚），于2011-07-28发行。   引入的新特性包括：   switch语句块中允许以字符串作为分支条件；   在创建泛型对象时应用类型推断；   在一个语句块中捕获多种异常；   支持动态语言；   支持try-with-resources；   引入Java NIO.2开发包；   数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；   钻石型语法；   null值的自动处理。Java Version SE 8   开发代号是Spider（蜘蛛），于2014-03-18发行。   支持 lambda支持；   增强日期与时间API的功能；   对垃圾回收的性能也进行了改进；   并且移除了permgen区。   Lambdas表达式与Functional接口   接口的默认与静态方法   方法引用   重复注解   更好的类型推测机制   扩展注解的支持\nJava体系结构JavaSEJavaSE（Java  Standard  Edition）：标准版，定位在个人计算机上的应用这个版本是Java平台的核心，它提供了非常丰富的API来开发一般个人计算机上的应用程序，包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。在上世纪90年代末互联网上大放异彩的Applet也属于这个版本。Applet后来为Flash取代，Flash即将被HTML5取代。\nJavaEEJavaEE（Java  Enterprise Edition）：企业版，定位在服务器端的应用JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：JDBC是让程序员能直接在Java内使用的SQL的语法来访问数据库内的数据；Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求；JSP是一种可以将Java程序代码内嵌在网页内的技术；\nJavaMEJavaME（Java  Micro  Edition）：微型版，定位在消费性电子产品的应用上JavaME是JavaSE的内伸，包含J2SE的一部分核心类，也有自己的扩展类,增加了适合微小装置的类库：javax.microedition.io.*等。该版本针对资源有限的电子消费产品的需求精简核心类库，并提供了模块化的架构让不同类型产品能够随时增加支持的能力。\nJava特性和优势跨平台/可移植性这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。\n1.安全性Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。\n2.面向对象面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！Java则是完全的面向对象语言。\n3.简单性Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于C语言，因此学习起来完全不费力。\n4.高性能Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，某些代码甚至接待C++的效率。因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。\n5.分布式Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，使程序能够通过网络调用方法。\n6.多线程多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。\n7.健壮性Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。\n总结一句话：Java很好！但是，并不是说学习了java，以后所有的东西都要用java开发了：某些领域其他语言有更出色的表现，比如，Objective C和后来的Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。只能说，不同语言之前，有各自的优势，主要看具体是要做什么项目，其实也是平分秋色的。\n","categories":["Java"],"tags":["Java_发展史"]},{"title":"数据类型","url":"/2021/12/22/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"数据类型标识符【1】标识符：读音   biao zhi fu【2】什么是标识符？  包，类，变量，方法…..等等,只要是起名字的地方,那个名字就是标识符【3】标识符定义规则：1.四个可以（组成部分）：数字，字母，下划线_，美元符号$注意：字母概念比较宽泛，指的是英文字母，汉字，日语，俄语……但是我们一般起名字尽量使用英文字母2.两个不可以：不可以以数字开头，不可以使用java中的关键字3.见名知意：增加可读性4.大小写敏感：  int a ;  int A;5.遵照驼峰命名： 类名：首字母大写，其余遵循驼峰命名 方法名，变量名：首字母小写，其余遵循驼峰命名 包名：全部小写，不遵循驼峰命名6.长度无限制，但是不建议太长  asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasfd\n关键字关键字：被JAVA语言赋予了特殊含义，用作专门用途的单词比如：clss、char、if、for特点：JAVA中所有关键字都为小写官网中关键字的说明：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\n变量和常量顾名思义，变量就是可以变化的量，而常量就是一个固定的数值。比如：int a；这里面的a没有赋值，所以在之后的操作中可以是10，20等很多值，即为变量。     int a=10；这里面a给了一个10为初始值，虽然后续也可以修改但是没改之前这个值都是不变的，即为常量。变量和常量的用途是不一样的，比如要是想定义一个年龄这种随着时间岁数回增长的，就可以定义为变量。\n基本数据类型Java是一种强类型语言，每个变量都必须声明其数据类型。Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。基本数据类型分为数值型、字符型、布尔型，其中数值型还分为整数类型和浮点类型。定义这些数据类型的代码分别是：整数：byte、short、int、long浮点数：float、double字符型：char布尔型：boolean引用数据类型分为类、接口、数组。定义这些数据类型的代码分别是：类：class接口：interface数组有很多种定义方法，在后面讲数组的文章会写到。\n","categories":["Java"],"tags":["Java_数据类型"]},{"title":"Java中的数组","url":"/2021/12/23/Java-%E6%95%B0%E7%BB%84/","content":"数组数组用来存储数据的，在程序设计中，为了处理方便，数组用来将相同类型的若干数据组织起来。这个若干数据的集合我们称之为数组。\n数组的定义数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引（下标）来访问它们。数组的四个基本特点：1.长度是确定的。数组一旦被创建，它的大小就是不可以改变的。2.其元素的类型必须是相同类型，不允许出现混合类型。3.数组类型可以是任何数据类型，包括基本类型和引用类型。4.数组有索引的：索引从0开始，到 数组.length-1 结束5.数组变量属于引用类型，数组也是对象。PS:数组变量属于引用类型，数组也是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。\n数组的定义方式数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。\n静态初始化除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。eg:int[] arr = {12,23,45};int[] arr = new int[]{12,23,45};\n动态初始化数组定义与为数组元素分配空间并赋值的操作分开进行。eg:int[] arr ;arr = new int[3]arr[0] = 12;arr[1] = 23;arr[2] = 45;\n默认初始化数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。数组是有初始默认值的。int[] arr = new int[3];\n数组的应用main方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口main方法格式严格要求：public static void main(String[] args){}public static 修饰符 ，暂时用这个 –&gt;面向对象一章voi d代表方法没有返回值 对应的类型voidmain 见名知意名字String[] args 形参，也就是不确定因素问题：程序中是否可以有其他的方法也叫main方法？可以，构成了方法的重载。\n二维数组二位数组的定义数组的内存分布\n二维数组的初始化方法数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。\n静态初始化除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。eg：int [] [] arr = { {1,2},{4,5,6} };int [] [] arr = new int [] [] { {1,2},{4,5,6} };\n动态初始化数组定义与为数组元素分配空间并赋值的操作分开进行。int [] [] arr = new int [1] [2]; \n默认初始化数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\n","categories":["Java"],"tags":["数组"]},{"title":"Java核心机制及部署","url":"/2021/12/22/Java-%E6%A0%B8%E5%BF%83/","content":"前言：此篇文章讲述的是如何在电脑搭建Java运行环境。\n核心机制常用DOS命令DOS操作系统–Microsoft公司推出的操作系统。（在windows之前的操作系统）–DOS是英文”Disk Operating System”的缩写,其中文含意是”磁盘操作系统”.–DOS是单用户、单任务的操作系统.（只能执行一个任务）就是大家经常用到的黑框框\nDOS命令–在windows中，我们通过鼠标菜单等来操作系统，而在dos操作系统中，要通过dos命令来操作系统。–是DOS操作系统的命令，是一种面向磁盘的操作命令，–不区分大小写。\n命令学习：windows给我们保留了类似dos系统的操作界面，可以直接操作磁盘！dos 也是一种操作系统，是在windows出现以前用的，后来windows出来后基本没人用了，但是当windows崩溃的时候，还是要的dos方式解决，它是一种纯命令方式，cmd其实就是在windows状态下进入dos方式。控制命令台：win+r—&gt;cmd具体dos命令：（1）切换盘符： c:  d:  e:   大小写没有区分（2）显示详细信息：dir（3）改变当前目录：cd +路径（4） . 当前目录 ..  代表上一层目录 如：cd ..就是切换为上一级目录 （5）清屏：cls（6）切换历史命令：上下箭头（7）补全命令： tab按键（8）创建目录：md ,删除目录：rd +文件名（9）复制文件命令：copy +文件名（10）删除文件：del +文件名del后面如果接的是文件夹/目录：那么删除的就是这个文件夹下的文件，而不是文件夹以上都是一些常用的DOS命令，在Linux系统和Mac中经常用到类似的命令，熟能生巧\nJava环境准备–&gt;装JDK【1】下载JDKOrcel官网中下载对应自己计算机操作系统的安装包：www.oracle.com/technetwork/java/javase/downloads/index.html【2】安装JDK选好安装路径，以后用Idea或者Eclipse配置时候需要用到JDK的路径，其他下一步即可。【3】卸载JDK控制面板卸载即可【4】 验证JDK是否安装成功在桌面上按windows+r然后输入cmd打开命令行然后输入：java -version若出现JDK版本就是安装成功了。【5】JDK和JRE：安装时候会安装JDK和JRE区别如下：JDK： Java Development kit   —-&gt;编写Java程序的程序员使用的软件JRE : Java Runtime Enviroment  —-》运行Java程序的用户使用的软件简单说就是只安装JRE就可以运行Java的程序但是不能进行编写。【6】配置环境变量path1.打开我的电脑属性选项2.左边菜单打开高级系统选项，然后打开环境变量3.新建环境变量叫：classpath 变量值为：.如：变量名：classpath   变量值：.classpath作用：只要你配置到classpath中的路径，在执行java的字节码文件的时候，就会去这个配置的路径下找对应的字节码文件，而写了.\\就可以全局运行Java了4.新建环境变量：JAVA_HOME:和上一步一样新建然后变量名输入JAVA_HOME，变量值为JDK的安装目录如：变量名：JAVA_HOME   变量值：C:\\Program Files\\Java\\jdk1.8.0_151这个环境变量是为了之后运行tomcat用的5.在path环境变量中加入自己安装JDK的路径加\\bin如：C:\\Program Files\\Java\\jdk1.8.0_151\\bin也可以新建一个path环境变量然后输入路径+\\bin至此我们电脑的Java的运行环境算是配好了\nAPI文档JDK帮助文档SUN公司为JDK工具包提供了一整套文档资料,我们习惯上称之为JDK文档。JDK文档中提供了Java中的各种技术的详细资料,以及JDK中提供的各种类的帮助说明。JDk文档是Java语言的完整说明,大多数书籍中的类的介绍都要参照它来完成,它是编程者经常查阅的资料如何理解API：就当做是一个“字典”，“使用手册”，API就相当于是一个电子的帮助文档，可以帮我们查看JDK提供的类的信息，平时查看的时候可结合百度一起看。其实API没有什么神奇的，就是一个电子文档而已，帮助我们查看JAVA中涉及到的一些技能点。\nHello World现在我们开始写我们的第一段代码了，实现一个输出HelloWorld的功能在任意位置建一个文件夹，起名为Java，然后在文件夹下新建一个txt文档，起名为HelloWorld.java。打开文档输入：public class HelloWorld{        public static void main(String[] args){                System.out.println(“hi 这是一段Java程序。。。”);        }}然后保存。打开我们的命令行，输入cd：java文件夹路径，进到我们这个文件夹里面。输入javac HelloWorld.java对我们写的java文件进行编译。编译完之后在文件夹下面会出现一个.class文件就编译好的文件。输入java HelloWorld运行程序在命令行中出现HelloWorld就成功了。注意：在写代码的时候要注意区分中英文的符号，所有符号必须是英文格式的，不然会出现编译错误。     我们的文件名和类名必须是一样的，不然也会出现编译错误。    编写代码时要注意格式排版，养成习惯，以后方便查看代码和BUG。        \n小练习：输出一个人的个人信息要求：在命令行中输出姓名，年龄，职业，身高，体重。代码如下：public class HiWorld{        public static void main(String[] args){                //进行自我介绍：                System.out.println(“姓名:”);                System.out.println(“丽丽”);                System.out.println(“职业:”);                System.out.println(“学生”);                System.out.println(“身高:”);                System.out.println(“180”);                System.out.println(“体重:”);                System.out.println(“130”);\n    &#125;\n\n}\n扩展：JDK、JRE、JVM的区别JDK和JRE的区别初学JAVA很容易被其中的很多概念弄的傻傻分不清楚，首先从概念上理解一下吧，JDK（Java Development Kit）简单理解就是Java开发工具包，JRE(Java Runtime Enviroment)是Java的运行环境，JVM( java virtual machine)也就是常常听到Java虚拟机。JDK是面向开发者的，JRE是面向使用JAVA程序的用户。\nJRE和JVM的区别JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，class文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行，类似于C#中的CLR。JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE，如果讲的具体点就是bin目录下的jvm.dll文件， jvm.dll无法单独工作，当jvm.dll启动后，会使用explicit的方法(就是使用Win32 API之中的LoadLibrary()与GetProcAddress()来载入辅助用的动态链接库)，而这些辅助用的动态链接库(.dll)都必须位 于jvm.dll所在目录的父目录之中。因此想使用哪个JVM，只需要设置PATH，指向JRE所在目录下的jvm.dll。\n","categories":["Java"],"tags":["Java_部署"]},{"title":"Java中的流程控制","url":"/2021/12/22/Java-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"流程控制【1】流程控制的作用：流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。【2】控制语句的分类：控制语句分为三类：顺序、选择和循环。“顺序结构”代表“先执行a，再执行b”的逻辑。“条件判断结构”代表“如果…，则…”的逻辑。“循环结构”代表“如果…，则再继续…”的逻辑。  三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。这三种基本逻辑结构是相互支撑的，它们共同构成了算法的基本结构，无论怎样复杂的逻辑结构，都可以通过它们来表达。所以任何一种高级语言都具备上述两种结构。本章是大家真正进入编程界的“门票”。【3】流程控制的流程：\n分支结构ifif(表达式){\n}else if(表达式){\n}else{\n}\nif语句会根据小括号里的表达式来判断如果满足条件，则进入对应的大括号，执行大括号里的代码，如果不满足则判断下一个else if，都不满足则执行else的大括号。例如：if(score&gt;=90){        System.out.println(“A级”);}else if(score&gt;=80){        System.out.println(“B级”);}\nswitchswitch多分支结构(多值情况)语法结构：switch (表达式) {    case 值1:         语句序列1;    case 值2:         语句序列2;        .        .        .}switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句的末尾。如果表达式的值与任一case值不匹配，则进入default语句（如果存在default语句的情况）。根据表达式值的不同可以执行许多不同的操作。switch语句中case标签在JDK1.5之前必须是整数（long类型除外）或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。大家要注意，当布尔表达式是等值判断的情况，可以使用if-else if-else多分支结构或者switch结构，如果布尔表达式区间判断的情况，则只能使用if-else if-else多分支结构。switch多分支结构的流程图如图所示：例如：switch(score/10){ case 3 : System.out.println(“A级”);break; case 2 : System.out.println(“B级”);break; case 1 : System.out.println(“C级”);break; default:System.out.println(“成绩错误”);break; case 0 : System.out.println(“D级”);break;}switch分支和if分支区别：表达式是等值判断的话–》if ，switch都可以如果表达式是区间判断的情况—》if最好switch应用场合：就是等值判断，等值的情况比较少的情况下      \n循环结构while语法结构：while (布尔表达式) {            循环体;}在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。while循环结构流程图如图所示:例如：int sum = 0; while(num&lt;=5){[2]条件判断  sum += num;[3]循环体  num++;[4]迭代}      \ndo-while语法结构：do {            循环体;    } while(布尔表达式) ; do-while循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体至少执行一次。 do-while循环结构流程图如图所示：  例如： int i = 101;int sum = 0;do{    sum += i;    i++;}while(i&lt;=100);//一定要注意写这个分号，否则编译出错System.out.println(i);//102System.out.println(sum);//101while和do-while的区别:while:先判断，再执行do-while:先执行，再判断—》至少被执行一次，从第二次开始才进行判断\nfor语法结构：for (初始表达式; 布尔表达式; 迭代因子) {          循环体;} for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for循环在第一次反复之前要进行初始化，即执行初始表达式；随后，对布尔表达式进行判定，若判定结果为true，则执行循环体，否则，终止循环；最后在每一次反复的时候，进行某种形式的“步进”，即执行迭代因子。初始化部分设置循环变量的初值条件判断部分为任意布尔表达式迭代因子控制循环变量的增减for循环在执行条件判定后，先执行的循环体部分，再执行步进。for循环结构的流程图如图所示：例如：int sum = 0;int i;for(i = 1;i&lt;=100;i++){sum += i;}System.out.println(sum);System.out.println(i);\nbreak和continue关键字在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。return的作用,结束当前所在方法的执行。\n循环的嵌套循环和条件判断分支都是可以进行多层嵌套使用的，很灵活。\n双重嵌套比如我要做一个乘法表，就可以用双重嵌套来实现。例如：public class TestFor11{    public static void main(String[] args){                //16=6   26=12  36=18  46=24  56=30  66=36                /*                System.out.print(“16=6”+”\\t”);                System.out.print(“26=12”+”\\t”);                System.out.print(“36=18”+”\\t”);                System.out.print(“46=24”+”\\t”);                System.out.print(“56=30”+”\\t”);                System.out.print(“66=36”+”\\t”);\n            for(int i=1;i&lt;=6;i++)&#123;\n                    System.out.print(i+&quot;*6=&quot;+i*6+&quot;\\t&quot;);\n            &#125;\n            //换行\n            System.out.println();\n            \n            //1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49\n            for(int i=1;i&lt;=7;i++)&#123;\n                    System.out.print(i+&quot;*7=&quot;+i*7+&quot;\\t&quot;);\n            &#125;\n            //换行\n            System.out.println();\n            \n            //1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64\n            for(int i=1;i&lt;=8;i++)&#123;\n                    System.out.print(i+&quot;*8=&quot;+i*8+&quot;\\t&quot;);\n            &#125;\n            //换行\n            System.out.println();\n            */\n            \n            for(int j=1;j&lt;=9;j++)&#123;\n                    for(int i=1;i&lt;=j;i++)&#123;\n                            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\\t&quot;);\n                    &#125;\n                    //换行\n                    System.out.println();\n            &#125;\n    &#125;\n\n}运行结果：11=112=2   22=413=3   23=6   33=914=4   24=8   34=12  44=1615=5   25=10  35=15  45=20  55=2516=6   26=12  36=18  46=24  56=30  66=3617=7   27=14  37=21  47=28  57=35  67=42  77=4918=8   28=16  38=24  48=32  58=40  68=48  78=56  88=6419=9   29=18  39=27  49=36  59=45  69=54  79=63  89=72  9*9=81\n","categories":["Java"],"tags":["Java_流程控制"]},{"title":"Java_运算符","url":"/2021/12/22/Java-%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"运算符算数运算符算数运算符就是平时用到的数学中的“+，-，*，/”，然后比较特殊的是取模：“%”，和自增自减：“++（自增），–（自减）”。\n赋值运算符例如：Java中赋值运算符是“=”，意思是把等号右边的数值赋给左边的内容。\npublic class Test1{        public static void main(String[] args){                //任意给出两个数，交换两个数并输出：                //1.给出两个数：                int num1 = 10;                int num2 = 20;\n            //2.输出交换前的两个数：\n            System.out.println(&quot;交换前：&quot;+num1+&quot;\\t&quot;+num2);\n            \n            //3.交换\n            /*\n            错误代码：\n            num1 = num2;\n            num2 = num1;    \n            */        \n            //解决办法：\n            //引入一个中间变量:\n            int t;\n            t = num1;\n            num1 = num2;\n            num2 = t;\n            /*\n            int t;\n            t = num2;\n            num2 = num1;\n            num1 = t;\n            \n            */\n            \n            //4.输出交换后的两个数：\n            System.out.println(&quot;交换后：&quot;+num1+&quot;\\t&quot;+num2);\n    &#125;\n\n}\n扩展赋值运算符把赋值运算符和算数运算符拼接起来的称为扩展赋值运算符。其中包括“+=，-=，*=，/=”举个例子：a+=10；这个式子结果与a=a+10一样，就是把a的数值加上10再赋值给a。如果原来定义的a值为5，则式子运算完结果就是15。但是a+=10和a=a+b是有区别的，a+=b的可读性稍差，但是编译效率高，是底层自动进行类型转换，a=a+b的可读性好但是编译效率低，需要手动进行类型转换。例如：public class Test2{        public static void main(String[] args){                //实现功能：给出三个数，求和：                //1.给出三个数：                int num1 = 10;                int num2 = 20;                int num3 = 30;                //2.求和                //int sum = num1+num2+num3;                //定义一个变量，用来接收和：                int sum = 0;                sum = sum + num1;//等效：  sum += num1;                sum = sum + num2;// sum += num2;                sum = sum + num3;//sum += num3;                //3.将和输出：                System.out.println(“和：”+sum);        }}\n关系运算符关系元素符是比较符号两遍大小的，有：&gt;，&lt;，&gt;=，&lt;=，==，!=。这里注意一下==，这个才是等于，两遍数值相等的时候，式子才成立，！=是不等于，两遍式子不想等的时候成立。例如：public class Test3{        public static void main(String[] args){                //&gt;，&lt;，&gt;=，&lt;=，==，!=                //关系运算符最终结果：要么是true要么是false                System.out.println(4&gt;9);//false                System.out.println(4&lt;9);//true                System.out.println(4&gt;=9);//false                System.out.println(4&lt;=9);//true                System.out.println(4==9);//false                System.out.println(4!=9);//true                System.out.println((5&lt;9)!=(6==8));//true        }}\n逻辑运算符逻辑运算符是进行逻辑运算的，在计算机组成与原理有讲过他们的运算，有：逻辑与：“&amp;”，逻辑或：“|“，短路与：”&amp;&amp;“，短路或：”||“，逻辑非：”!“，逻辑异或：”^“。这些运算的结果只有true或者false，也就是真或者假。短路的于或比正常的与或的执行效率更高一些。例如：public class Test4{        public static void main(String[] args){                int i=8;                System.out.println((5&gt;7)&amp;&amp;(i++==2)); //false                System.out.println(i);  //8 \n            int a=8;\n            System.out.println((5&gt;7)&amp;(a++==2)); //false\n            System.out.println(a); //9\n            \n            \n            int m=8;\n            System.out.println((5&lt;7)&amp;&amp;(m++==2)); //false\n            System.out.println(m); //9\n            \n            int b=2;\n            System.out.println((5&lt;7)&amp;(b++==2)); //true\n            System.out.println(b);  //3\n            \n            int c=2;\n            System.out.println((5&lt;7)&amp;(++c==2)); //false\n            System.out.println(c);  //3\n    &#125;\n\n}\n位运算符位运算符是处理数据移位的运算符，有：&amp;，|，^，取反：“~” ， 右移：“&gt;&gt;”，左移：“&lt;&lt;”，无符号右移：“&gt;&gt;&gt;”。前面三个与逻辑运算符长得一样，要区分他们具体是哪一个，看符号两边的数据类型，如果左右连接的是布尔类型的操作数，就是逻辑运算符，如果左右连接的是具体的数值，就是位运算符。位运算不是很常用，了解即可。\n条件运算符条件运算符是if语句的简化版，也称三元运算符或者三目运算符，写法是：“ a？b ：c ”.其中a是一个布尔类型的表达式，返回结果要么是true要么false，通过a的结果决定最终表达式的结果:如果a的结果是true，那么表达式最终结果为b如果a的结果是false，那么表达式最终结果为c例如：public class Test5{        public static void main(String[] args){                int num = (5&gt;7)?6:9 ;                System.out.println(num);\n            String str = (4==4)?&quot;你好&quot;:&quot;你不好&quot; ;\n            System.out.println(str);\n            \n            System.out.println((4==4)?&quot;你好&quot;:&quot;你不好&quot;);\n    &#125;\n\n}\n运算符的优先级别我们不需要去刻意的记优先级关系，因为开发中不会特意去写特别复杂的表达式。优先级是：赋值&lt;三目&lt;逻辑&lt;关系&lt;算术&lt;单目。其实就相当于数学中乘除法优先计算于加减法，但是有括号先算括号里的。这个也是这个意思\n","categories":["Java"],"tags":["Java_运算符"]},{"title":"Hello World","url":"/2021/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Java中的内存分析","url":"/2021/12/23/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/","content":"内存分析栈、堆、方法区 {    int id; int age; person p1 = new person(); } 局部变量，方法在栈里，创建的对象在堆里。\nthisthis关键字 用法：1.this可以修饰属性：总结：当属性名字和形参发生重名的时候，或者  属性名字 和局部变量重名的时候，都会发生就近原则，所以如果我要是直接使用变量名字的话就指的是离的近的那个形参或者局部变量，这时候如果我想要表示属性的话，在前面要加上：this.修饰如果不发生重名问题的话，实际上你要是访问属性也可以省略this. {  public class Person {    //属性    int age;    String name;    double height;    //空构造器    public Person(){    }    //有参构造器    public Person(int age,String name,double height){        this.age = age;        this.name = name;        this.height = height;    }    //方法：    public void eat(){        int age = 10;        System.out.println(age);//就近原则，age指的是离它近的age–》局部变量的age        System.out.println(this.age);//这里指代的就是属性的age        System.out.println(“我喜欢吃饭”);    } }2.this修饰方法：总结：在同一个类中，方法可以互相调用，this.可以省略不写。 {  public class Person {    //属性    int age;    String name;    double height;    //空构造器    public Person(){    }    //有参构造器    public Person(int age,String name,double height){        this.age = age;        this.name = name;        this.height = height;    }    //方法：    /public void eat(){        int age = 10;        System.out.println(age);//就近原则，age指的是离它近的age–》局部变量的age        System.out.println(this.age);//这里指代的就是属性的age        System.out.println(“我喜欢吃饭”);    }/    public void play(){        /this./eat();        System.out.println(“上网”);        System.out.println(“洗澡”);    }    public void eat(){        System.out.println(/this./age);        System.out.println(“吃饭”);    } }3.this可以修饰构造器：总结：同一个类中的构造器可以相互用this调用，注意：this修饰构造器必须放在第一行 {    public class Person {    //属性    int age;    String name;    double height;    //空构造器    public Person(){    }    //有参构造器    public Person(int age,String name,double height){        this(age,name);        this.height = height;    }    public Person(int age,String name){        this(age);        this.name = name;    }    public Person(int age){        this.age = age;    }    //方法：    /public void eat(){        int age = 10;        System.out.println(age);//就近原则，age指的是离它近的age–》局部变量的age        System.out.println(this.age);//这里指代的就是属性的age        System.out.println(“我喜欢吃饭”);    }/    public void play(){        /this./eat();        System.out.println(“上网”);        System.out.println(“洗澡”);    }    public void eat(){        System.out.println(/this./age);        System.out.println(“吃饭”);    } }\nstaticstatic可以修饰：属性，方法，代码块，内部类。1.static修饰属性 {  public class Test {    //属性：    int id;    static int sid;    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //创建一个Test类的具体的对象        Test t1 = new Test();        t1.id = 10;        t1.sid = 10;        Test t2 = new Test();        t2.id = 20;        t2.sid = 20;        Test t3 = new Test();        t3.id = 30;        t3.sid = 30;        //读取属性的值：        System.out.println(t1.id);        System.out.println(t2.id);        System.out.println(t3.id);        System.out.println(t1.sid);        System.out.println(t2.sid);        System.out.println(t3.sid);    } }static修饰属性总结：（1）在类加载的时候一起加载入方法区中的静态域中（2）先于对象存在（3）访问方式： 对象名.属性名    类名.属性名（推荐）static修饰属性的应用场景：某些特定的数据想要在内存中共享，只有一块 –》这个情况下，就可以用static修饰的属性\nstatic修饰方法 {  public class Demo {    int id;    static int sid;    public void a(){        System.out.println(id);        System.out.println(sid);        System.out.println(“——a”);    }    //1.static和public都是修饰符，并列的没有先后顺序，先写谁后写谁都行    static public void b(){        //System.out.println(this.id);//4.在静态方法中不能使用this关键字        //a();//3.在静态方法中不能访问非静态的方法        //System.out.println(id);//2.在静态方法中不能访问非静态的属性        System.out.println(sid);        System.out.println(“——b”);    }    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //5.非静态的方法可以用对象名.方法名去调用        Demo d = new Demo();        d.a();        //6.静态的方法可以用   对象名.方法名去调用  也可以 用  类名.方法名 （推荐）        Demo.b();        d.b();    } }\n代码块类的组成：属性，方法，构造器，代码块，内部类代码块分类：普通块，构造块，静态块，同步块（多线程）代码： {  public class Test {    //属性    int a;    static int sa;    //方法    public void a(){        System.out.println(“—–a”);        {            //普通块限制了局部变量的作用范围            System.out.println(“这是普通块”);            System.out.println(“—-000000”);            int num = 10;            System.out.println(num);        }        //System.out.println(num);        //if(){}        //while(){}    }    public static void b(){        System.out.println(“——b”);    }    //构造块    {        System.out.println(“——这是构造块”);    }    //静态块    static{        System.out.println(“—–这是静态块”);        //在静态块中只能方法：静态属性，静态方法        System.out.println(sa);        b();    }    //构造器    public Test(){        System.out.println(“这是空构造器”);    }    public Test(int a){        this.a = a;    }    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        Test t = new Test();        t.a();        Test t2 = new Test();        t2.a();    } }总结：代码块执行顺序：最先执行静态块，只在类加载的时候执行一次，所以一般以后实战写项目：创建工厂，数据库的初始化信息都放入静态块。一般用于执行一些全局性的初始化操作。再执行构造块，（不常用）再执行构造器，再执行方法中的普通块\n包包的作用：为了解决重名问题（实际上包对应的就是盘符上的目录），解决权限问题。创建包包名定义：（1）名字全部小写（2）中间用.隔开（3）一般都是公司域名倒着写 ：  com.jd   com.msb（4）加上模块名字： com.jd.login    com.jd.register（5）不能使用系统中的关键字：nul,con,com1—com9…..（6）包声明的位置一般都在非注释性代码的第一行：总结：（1）使用不同包下的类要需要导包： import **..;  例如：import java.util.Date;（2）在导包以后，还想用其他包下同名的类，就必须要手动自己写所在的包。（3）同一个包下的类想使用不需要导包，可以直接使用。（4）在java.lang包下的类，可以直接使用无需导包：（5）IDEA中导包快捷键：alt+enter    可以自己设置自动导包（6）可以直接导入*：\n","categories":["Java"],"tags":["内存分析"]},{"title":"面向对象","url":"/2021/12/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"面向过程和面向对象的区别面向过程：当事件比较简单的时候，利用面向过程，注重的是事件的具体的步骤/过程，注重的是过程中的具体的行为，以函数为最小单位，考虑怎么做。面向对象：注重找“参与者”,将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。案例：人把大象装进冰箱：面向过程：函数1：打开冰箱(){人站在冰箱前，打开冰箱，冰箱卡到30度角的时候，冰箱的灯打开了………}函数2：储存大象(){大象先迈左腿，再迈右退，考虑冰箱能不能装下……}函数3：关闭冰箱(){人站在冰箱前，关闭冰箱，冰箱开到30度角的时候，冰箱的灯关闭了……….}\n面向对象：人{打开(冰箱){冰箱.打开();}\n存储(大象){        大象.进入();}\n关闭(冰箱){冰箱.关闭();}}\n冰箱{打开（）{ 1.2.3.} 关闭（）{}}\n柜子{\n}\n大象{进入(冰箱){}}面向过程 —&gt; 面向对象 , 其实就是由执行者 —&gt; 指挥者的 一个过渡\n类和对象的关系1.万事万物皆对象，身边所有的事物都是对象2.对象：具体的事物，具体的实体，具体的实例，模板下具体的产品  类：对对象向上抽取出像的部分，公共的部分，形成类，类是抽象的，是一个模板。相当于类是有相同特征的对象的集合。3.一般在写代码的时候先写类，然后在根据类创建对应的对象。\n面向对象的三个阶段1.面向对象分析OOA  –  Object Oriented Analysis对象：张三，王五，朱六，你，我抽取出一个类—-》人类类里面有什么：动词–》动态特性–》方法名词–》静态特性–》属性2.面向对象设计OOD  –  Object Oriented Design先有类，再有对象：类：人类： Person对象：zhangsan ，lisi，zhuliu3.面向对象编程OOP  –  Object Oriented Programming\n创建创建类1）属性（field 成员变量）属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。属性定义格式：[修饰符]  属性类型  属性名 = [默认值] ;\n（2）方法方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。方法定义格式：[修饰符]  方法返回值类型  方法名(形参列表) {        // n条语句}void代表没有返回值；方法的作用：重用代码，封装功能，便于修改。代码：public class Person {    //名词—》属性—》成员变量—》放在类中方法外（注意：我们只把有需要的内容写到代码里，不相关的东西不要放在代码中）    int age ;//年龄    String name;//姓名    double height;//身高    double weight;//体重    //动词—》方法    //吃饭    public void eat(){        int num = 10;//局部变量：放在方法中        System.out.println(“我喜欢吃饭”);    }    //睡觉：    public void sleep(String address){        System.out.println(“我在”+address+”睡觉”);    }    //自我介绍：    public String introduce(){        return “我的名字是：”+name+”，我的年龄是：”+age+”,我的身高是：”+height+”,我的体重是：”+weight;    }}\n创建对象public class Test {//测试类    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //创建一个人类的具体的对象/实例：        //创建一个对象，对象的名字叫：zs        //Person 属于 引用数据类型        //第一次加载类的时候，会进行类的加载，初始化创建对象的时候，对象的属性没有给赋值，有默认的初始化的值。        Person zs = new Person();        zs.name = “张三”;        zs.age = 19;        zs.height = 180.4;        zs.weight = 170.4;        //再创建一个对象：        //再次创建类的时候，就不会进行类的加载了，类的加载只在第一次需要的时候加载一次        Person ls = new Person();        ls.name = “李四”;        ls.age = 18;        ls.height = 170.6;        ls.weight = 160.5;        //对属性值进行读取：        System.out.println(zs.name);        System.out.println(ls.age);        //对方法进行操作：        //不同的对象，属性有自己的特有的值，但是方法都是调用类中通用的方法。        //属性：各个对象的属性是独立的，        //方法：各个对象的方法是共享的。        zs.eat();        ls.eat();        zs.sleep(“教室”);        /String str = zs.introduce();        System.out.println(str);/        System.out.println(zs.introduce());    }}\n构造器public class Test {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //创建一个Person类的具体的对象/实例/实体：        /*        创建对象的过程：        1.第一次遇到Person的时候，进行类的加载（只加载一次）        2.创建对象，为这个对象在堆中开辟空间        3.为对象进行属性的初始化动作        new关键字实际上是在调用一个方法，这个方法叫构造方法（构造器）        调用构造器的时候，如果你的类中没有写构造器，那么系统会默认给你分配一个构造器，只是我们看不到罢了。        可以自己显式 的将构造器编写出来：        构造器的格式：        [修饰符] 构造器的名字(){        }        构造器和方法的区别：        1.没有方法的返回值类型        2.方法体内部不能有return语句        3.构造器的名字很特殊，必须跟类名一样        构造器的作用：不是为了创建对象，因为在调用构造器之前，这个对象就已经创建好了，并且属性有默认的初始化的值。        调用构造器的目的是给属性进行赋值操作的。        注意：我们一般不会在空构造器中进行初始化操作，因为那样的话每个对象的属性就一样了。        实际上，我们只要保证空构造器的存在就可以了，里面的东西不用写         */        Person p = new Person();        System.out.println(p.age);        System.out.println(p.name);        System.out.println(p.height);        Person p2 = new Person();        System.out.println(p2.age);        System.out.println(p2.name);        System.out.println(p2.height);    }}\n","categories":["Java"],"tags":["面向对象"]},{"title":"Java中的方法","url":"/2021/12/23/Java-%E6%96%B9%E6%B3%95/","content":"方法的定义、调用、重载方法的定义和调用什么是方法？方法(method)就是一段用来完成特定功能的代码片段，类似于其它语言的函数(function)。方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。\n方法声明格式[修饰符1  修饰符2  …]  返回值类型    方法名(形式参数列表){        Java语句；}\n方法的调用方式对象名.方法名(实参列表)\n方法的详细说明形式参数：在方法声明时用于接收外界传入的数据。实参：调用方法时实际传给方法的数据。返回值：方法在执行完毕后返还给调用它的环境的数据。返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。代码：\npublic class TestMethod01{\n    //方法的定义：（写方法）\n    public static int add(int num1,int num2)&#123;\n            int sum = 0;\n            sum += num1;\n            sum += num2;\n            return sum;//将返回值返回到方法的调用处\n    &#125;\n    \npublic static void main(String[] args)&#123;\n            //10+20:\n            //方法的调用：（用方法）\n            int num = add(10,20);\n            System.out.println(num);\n            /*\n            int num1 = 10;\n            int num2 = 20;\n            int sum = 0;\n            sum += num1;\n            sum += num2;\n            System.out.println(sum);\n            */\n            //30+90:\n            int sum = add(30,90);\n            System.out.println(sum);\n            /*\n            int num3 = 30;\n            int num4 = 90;    \n            int sum1 = 0 ;\n            sum1 += num3;\n            sum1 += num4;\n            System.out.println(sum1);\n            */\n            //50+48:\n            System.out.println(add(50,48));\n    \n    &#125;\n    \n    \n\n}\n总结1.方法是：对特定的功能进行提取，形成一个代码片段，这个代码片段就是我们所说的方法2.方法和方法是并列的关系，所以我们定义的方法不能写到main方法中3.方法的定义–》格式：        修饰符 方法返回值类型 方法名(形参列表){                方法体;                return 方法返回值;        }\n4.方法的作用：提高代码的复用性5.总结方法定义的格式：\n\n修饰符: 暂时使用public static —&gt;面向对象一章讲解\n方法返回值类型  : 方法的返回值对应的数据类型数据类型： 可以是基本数据类型（byte,short,int,long,float,double,char,boolean） 也可以是引用数据类型 \n方法名 :见名知意，首字母小写，其余遵循驼峰命名，  eg: addNum ,一般尽量使用英文来命名  \n形参列表 :方法定义的时候需要的形式参数 ：  int  num1, int num2 –&gt;相当于告诉方法的调用者：需要传入几个参数，需要传入的参数的类型 实际参数：方法调用的时候传入的具体的参数：  10,20  –&gt;根据形式参数的需要传入的\n\n5)方法体：具体的业务逻辑代码6) return 方法返回值;方法如果有返回值的话： return+方法返回值，将返回值返回到方法的调用处方法没有返回值的话：return可以省略不写了，并且方法的返回值类型为：void\npublic class TestMethod02{\n    public static void add(int num1,int num2)&#123;\n            int sum = 0;\n            sum += num1;\n            sum += num2;    \n            System.out.println(sum);\n            //return; \n    &#125;\n    \npublic static void main(String[] args)&#123;\n            //10+20:\n            //方法的调用：（用方法）\n            add(10,20); \n            //30+90:\n            add(30,90);\n            //50+48:\n            //System.out.println(add(50,48));//报错：TestMethod02.java:22: 错误: 此处不允许使用 &#39;空&#39; 类型\n\n    &#125;\n\n}\n什么时候有返回值，什么时候没有返回值？ 看心情–》看需求\n6.方法的定义需要注意什么？1）形参列表要怎么写：定义几个参数，分别是什么类型的  —》不确定因素我们会当做方法的形参2)  方法到底是否需要返回值 ，如果需要的话，返回值的类型是什么\n7.方法的调用需要注意什么？1）实际参数要怎么传入：传入几个参数，传入什么类型的2） 方法是否有返回值需要接受\n例子问下列代码中两个数是否交换成功public class TestM{        public static void main(String[] args){                int a=10;                int b=20;                System.out.println(“输出交换前的两个数：”+a+”—“+b);                changeNum(a,b);                System.out.println(“输出交换后的两个数：”+a+”—“+b);        }        public static void changeNum(int num1,int num2){                int t;                t=num1;                num1=num2;                num2=t;        }}答：\n方法的重载什么是方法的重载：方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。\n注意本质：重载的方法，实际是完全不同的方法，只是名称相同而已！\n构成方法重载的条件：不同的含义：形参类型、形参个数、形参顺序不同只有返回值不同不构成方法的重载如：int a(String str){}与 void a(String str){}不构成方法重载只有形参的名称不同，不构成方法的重载如：int a(String str){}与int a(String s){}不构成方法重载\n代码public class TestMethod05{    public static void main(String[] args){                //10+20:                int sum = add(10,20);                System.out.println(sum);\n            //20+40+80:\n            //System.out.println(add(add(20,40),80));\n            System.out.println(add(20,40,80));\n            //30+60+90+120:\n            //System.out.println(add(add(30,60),add(90,120)));\n            System.out.println(add(30,60,90,120));\n            //9.8+4.7:\n            //System.out.println(add(9.8,4.7));\n            System.out.println(add(9.8,4.7));\n    &#125;\n    \n    //定义一个方法：两个数相加：两个int类型数据相加\n    public static int add(int num1,int num2)&#123;\n            return num1+num2;\n    &#125;\n    \n    //定义一个方法：三个数相加：\n    public static int add(int num1,int num2,int num3)&#123;\n            return num1+num2+num3;\n    &#125;\n    \n    //定义一个方法：四个数相加：\n    public static int add(int num1,int num2,int num3,int num4)&#123;\n            return num1+num2+num3+num4;\n    &#125;\n    //定义一个方法：两个数相加：两个double类型的数据相加\n    public static double add(double num1,double num2)&#123;\n            return num1+num2;\n    &#125;\n    \n    \n\n}\n总结1.方法的重载：在同一个类中，方法名相同，形参列表不同的多个方法，构成了方法的重载。2.方法的重载只跟：方法名和形参列表有关，与修饰符，返回值类型无关。3.注意：形参列表不同指的是什么？（1）个数不同add()   add(int num1)   add(int num1,int num2)（2）顺序不同add(int num1,double num2)   add(double num1,int num2)（3）类型不同add(int num1)   add(double num1)\n4.请问下面的方法是否构成了方法的重载？(1)add(int a)  和  add(int b)   —&gt;不构成,相当于方法的重复定义(2)public static int add(int a) 和  public static void add(int b)  —&gt;不构成\n扩充：public class TestMethod06{    public static void main(String[] args){                add(5);                //级别：byte,short,char–&gt;int–&gt;long–&gt;float—&gt;double        }\n    public static void add(double num1)&#123;\n            System.out.println(&quot;------2&quot;);\n    &#125;\n    public static void add(float num1)&#123;\n            System.out.println(&quot;------3&quot;);\n    &#125;\n    public static void add(long num1)&#123;\n            System.out.println(&quot;------4&quot;);\n    &#125;\n    /*\n    public static void add(int num1)&#123;\n            System.out.println(&quot;------1&quot;);\n    &#125;\n    */\n\n}\n","categories":["Java"],"tags":["方法"]},{"title":"博客简介","url":"/2021/12/22/%E7%AE%80%E4%BB%8B/","content":"本博客于大学开始制作，记录学习记录和学习过程遇到的问题和解决办法。博客设有分类和标签搜索功能，方便大家查找内容。如遇到问题，可在评论区留下你的问题和建议。谢谢大家阅读。\nThis blog was created at the university to record learning records and problems encountered in the learning process and solutions.The blog is equipped with classification and tag search functions to make it easy for everyone to find content.If you encounter problems, you can leave your questions and suggestions in the comment area.Thank you all for reading.\n","tags":["简介"]},{"title":"final修饰符","url":"/2022/03/07/final%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"final可以修饰变量public class Test {    public static void main(String[] args) {        final int a = 10; //final 修饰变量，变量的值不可以改变，常量变为看了一个字符常量，规定常名字要大写。        final Dog d =new Dog(); //地址值不变，对象的属性仍然可以改变        final Dog d2 = new Dog();        a(d2);        b(d2);    }    public static void a(Dog d){        d= new Dog(); // d的指向可以被改变    }    public static void b(final Dog d){        d= new Dog(); // d被final修饰了，指向不能被改变    }}\n修饰方法public class Person {    final public void eat(){        System.out.println(“吃饭”);    }}class Student extends Person{    public void eat(){ //方法不能被重写        super.eat();    }}\n修饰类public final class Person { //final修饰类，此类不能被继承     public void eat(){        System.out.println(“吃饭”);    }}\n","categories":["Java"],"tags":["修饰符"]},{"title":"Java三大特性","url":"/2022/03/07/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","content":"Java的三大特性封装封装的概念封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在Java中通过关键字private,protected和public实现封装。封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。简单说封装将某些东西进行隐藏，然后提供相应的方式进行获取。\n高内聚，低耦合高内聚：类的内部数据操作细节自己完成，不允许外部干涉。低耦合：仅对外暴露少量的方法用于使用。隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。\n封装的好处封装可以提高代码的安全性。\n代码public class Girl {    private int age;\npublic int getage()&#123;\n    return age;\n\n}\npublic void setage(int age) &#123;\n    if (age &gt;= 30) &#123;\n        this.age = 18;\n    &#125; else &#123;\n        this.age = age;\n    &#125;\n&#125;\n\n}\npublic class Test {    public static void main(String[] args) {    Girl g = new Girl();    g.setage(31);    System.out.println(g.getage());    }}\n上面的代码，对于属性age来说，加了修饰符private,这样外界对他的访问就受到了限制，现在我还想再加上其他的限制条件，但是在属性本身上没有办法再加了，所以我们通过定义方法进行限制条件的添加。（1）将属性私有化，被private修饰（2）提供了public修饰符的方法可以让别人来访问（3）即使外界可以通过方法来访问属性，但是也不能随意访问，因为我们可以在方法中添加限制条件。IDEA中可以用快捷键alt+insert来进行自动添加set，get方法。注意：如果改了set，get方法的话，创建构造器后最好调用方法，不然容易出错。\n继承 extends继承的概念类是对对象的抽象，继承是对类的抽象。举例：学生类：属性：姓名，年龄，身高，学生编号方法：吃饭，睡觉，学习\n老师类：属性：姓名，年龄，身高，教师编号方法：吃饭，睡觉，教学\n员工类：属性：姓名，年龄，身高，员工编号方法：吃饭，睡觉，工作\n把共同的东西抽象为一个新的类：人类：属性：姓名，年龄，身高方法：吃饭，睡觉学生类，教师类，员工类都继承自人类\n写代码时候先定义人类\n人类： –&gt; 父类\n属性：姓名，年龄，身高方法：吃饭，睡觉\n再定义： –&gt; 子类\n学生类：属性：学生编号方法：学习教师类：属性：教师编号方法：教学员工类：属性：员工编号方法：工作子类继承自父类，这种继承关系，是在合理的范围中的抽取，抽取出子类父类的关系。\n代码public class Person {    private int age;    private String name;    private double hight;\npublic int getAge() &#123;\n    return age;\n&#125;\n\npublic void setAge(int age) &#123;\n    this.age = age;\n&#125;\n\npublic String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n\npublic double getHight() &#123;\n    return hight;\n&#125;\n\npublic void setHight(double hight) &#123;\n    this.hight = hight;\n&#125;\n\npublic void eat()&#123;\n\n&#125;\npublic void sleep()&#123;\n\n&#125;\n\n}\npublic class Student extends Person{//子类Student 继承 父类    private int sno;//学号\npublic int getSno() &#123;\n    return sno;\n&#125;\n\npublic void setSno(int sno) &#123;\n    this.sno = sno;\n&#125;\n\npublic void study()&#123;\n    System.out.println(&quot;学生可以学习&quot;);\n\n&#125;\n\n}\npublic class Test {    public static void main(String[] args) {    Student s1 = new Student();    s1.setSno(1001);    s1.setAge(15);    s1.setHight(178.5);    s1.setName(“李立”);        System.out.println(“姓名：”+s1.getName()+”年龄：”+s1.getAge()+”身高为：”+s1.getHight()+”学号：”+s1.getSno());    }}提高了代码的复用性，不用重复定义注意：父类的private修饰的内容，子类实际上也继承了，子类不能直接调用，但是通过set，get方法可以间接的调用。\n继承的好处(1)提高了代码的复用性，不用重复定义(2)便于代码的扩展(3)为了以后多态的使用，是多态的前提。注意：一个父类可以有多个子类，一个子类只能直接的继承于一个父类，但是继承具有传递性，可以间接的继承其他类。\n权限修饰符private 私有的，只在当前类里有效default 省略的，同一个类和包都可以访问protected 同一个类，包和子类可以访问public 所有的地方多可以访问属性，方法：修饰符：四种都可以用类：修饰符：可以用省略的或者public一般属性用private，方法用public\n方法的重写发生在子类和父类中，当父类提供的方法不满意时，要对父类的方法进行重写。格式要求：子类和父类的方法名，参数列表（个数，顺序，类型）必须一样\n重载和重写的区别重载发生在同一个类中，方法名一样，形参列表不同的时候重写发生在不同类，子类对父类的方法进行重写。\nsuper修饰符super指的是父类，通常情况下可以省略，当属性或者方法重复时，访问父类必须写super。和this用法类似。super还可以修饰构造器，调用父类的构造器，一般省略不写。要放在第一行，所以super和this不能同时调用构造器。IDEA中写构造器可以用快捷键，alt+insert\n多态泛化先写子类，然后抽象出共同点为父类，叫泛化\n多态多态即使多种状态，同一个行为，不同的子类表现出来的不同的形态。多态指的就是同一个方法调用，然后用于对象不同会产生不同的行为。好处：为了提高代码的扩展性，符合面向对象原则（开闭原则-扩展是开放的，修改是关闭的）。但是虽然扩展性没有达到最好，还有反射可以吧扩展性达到最好。多态的三个要素：继承，重写，父类引用指向子类对象。\n代码public class Animal {    public void shout(){        System.out.println(“我是动物，我可以叫”);    }}public class Cat extends Animal{    public void shout(){        System.out.println(“我是小猫，我可以喵喵叫”);    }    public void scratch(){        System.out.println(“我是小猫，我可以挠人”);    }}public class Dog extends Animal{    public void shout(){        System.out.println(“我是小狗，我可以叫”);    }    public  void guard(){        System.out.println(“我是小狗，我可以保护主人”);    }}public class Girl {    public void play(Animal an){        an.shout();    }}public class Test {    public static void main(String[] args) {        Girl g = new Girl();        Cat c = new Cat();        Dog d = new Dog();        Animal an = d;        g.play(an);    }}上面的代码中，是一种常见的应用场景，父类当方法的形参，传入的是具体的子类的对象，然后调用同一个方法，根据传入的子类的不同展现出来的效果也不同，构成了多态。\n","categories":["Java"],"tags":["特性"]},{"title":"抽象类","url":"/2022/03/07/%E6%8A%BD%E8%B1%A1%E7%B1%BB/","content":"抽象类和抽象方法关系抽象类中可以定义0-n个抽象方法\n作用在抽象类中定义抽象方法，目的是为了给子类提供一个通用的模板。子类可以在模板的基础上进行开发，西安重写父类的抽象方法，然后可以扩展子类自己的技能，抽象类设计避免了子类设计的随意性，通过抽象类，子类的设计变得更加严格，进行某种程度上的限制。使子类更加的通用。\n代码public abstract class Person {    //一个类中如果有抽象方法，则这个类也要变成一个抽象类,一个抽象类中可以有0-n个抽象方法    //在一个类中，会有一类方法，子类对这个方法非常满意，无需重写，直接使用    public void eat(){        System.out.println(“吃饭”);    }    //在一个类中，子类对这个方法永远不满意，会对这个方法进行重写    public abstract void say();//一个方法去掉方法体，然后用abstract修饰，那么这个方法就变成了一个抽象方法    public abstract void sleep();}//抽象类可以被其他类继承//一个类继承一个抽象类，那么这个类可以变成抽象类//一般子类不会加abstract修饰，一般让子类重写父类中的抽象方法class Student extends Person{    @Override    public void say() {        System.out.println(“我喜欢说话”);    }\n@Override //子类继承抽象类，就必须重写全部的抽象方法，子类如果没有重写父类的全部抽象方法，那么子类也可以变成一个抽象类\npublic void sleep() &#123;\n    System.out.println(&quot;我喜欢睡觉&quot;);\n&#125;\n\n}class Demo{    public static void main(String[] args) {        //创建抽象类的对象–&gt;抽象类不可以创建对象        //创建子类对象        Student s = new Student();        s.say();        s.sleep();    }}\n注意1.抽象类中一定有构造器，构造器的作用是给子类初始化对象的时候要西安super调用父类的构造器2.抽象方法不能被final修饰，因为抽象类设计的初衷就是给子类继承用的，要是被final修饰了，就不存在继承了，没有子类了\n","categories":["Java"],"tags":["类"]},{"title":"接口","url":"/2022/03/07/%E6%8E%A5%E5%8F%A3/","content":"接口作用定义规则，但是不同于抽象类，他是接口不是类，接口定义好规则后，实现类负责实现即可\n继承和接口：继承：子类堆父类的继承实现：实现类对接口的实现eg：手机 是不是 照相机继承： 手机 extends 照相机 = （xx是xx）世纪是一个照相机实现：手机 implements 拍照功能 = （xx有xx的功能）手机有一个照相的功能\n接口的使用 1.类试试类，接口是接口，他们是同一层次的概念 2.接口中没有构造器 3.声明接口：Interface 4.在JDK1.8中灭苦中只有两部分内容 （1）常量:固定修饰符：public static final （2）抽象方法：固定修饰符：public abstract  在JDK1.8之后新增了非抽象方法  （1）被public default修饰的非抽象方法  （2）静态方法 5.类和接口之间的关系：实现的关系，类实现接口： 6.一旦实现一个接口，那么实现类要重写接口中的全部抽象方法 7.如果没有全部重写方法，则把类变为抽象类 8.java只有单继承，java还有多实现: 一个类继承其他类，只能继承一个父类 实现接口，可以实现多个接口 9.写法：先继承后实现，比如：class Student extends Person implements TestInterface01,TestInterface02 10.接口不能创建对象，接口可以指向实现类\n多态的应用场合1.父类当作方法的形参，传入具体的子类的对象2.父类当作方法的返回值，返回的是具体的子类的对象3.接口当作方法的形参，传入具体的实现类的对象4.接口当作方法的返回值，返回的具体的实现类对象\n接口和抽象类的区别抽象类抽象类使用abstract修饰；不能被实例化，即不能用new关键字实例化对象；含有抽象方法的类是抽象类，必须用abstract关键字修饰；抽象类可以含有抽象方法，也可以不包括抽象方法，抽象类中可以有具体的方法；如果一个子类实现了父类，的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；抽象类中的抽象方法只有方法体，没有具体实现。\n接口接口使用interface修饰；接口不能被实例化；一个类可以实现多个接口；接口中的方法都是抽象方法；接口中不能包括实例域或静态方法（静态方法必须被实现，接口中都是抽象方法，不能被实现）。\n","categories":["Java"],"tags":["接口"]},{"title":"简单工厂模式","url":"/2022/03/12/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"简单工厂模式定义一个static方法，通过类名直接调用，返回值类型是父类类型，返回的可以是其任意子类类型，传入一个字符串型的参数，工厂根据参数创建对应的子类产品。\n代码public class PetStore { //动物工厂    public static Animal getAnimal(String petName){ //传入宠物类型    Animal an = null; //初始化an    if(“猫”.equals(petName)){ //把传入的宠物子类类型赋值给父类        an = new Cat();    }    if(“狗”.equals(petName)){        an = new Dog();    }    return an;  //返回父类    }}\n","categories":["设计模式"],"tags":["简单工厂"]},{"title":"Object类","url":"/2022/03/12/Object%E7%B1%BB/","content":"Object类toString()方法输出对象名的时候其实调用了toString方法，只不过省略不写了。System.out.print(s)==System.out.print(s.toString())。作用是：返回一个值：getClass().getName()+@+Integer.toHexString(hashCode()) ，比如com.msb.msb5.Student@1b6d3586，包名加类名加@哈希码的无无符号十六进制数hashCode将对象在堆中的地址，进行哈希算法，返回一个码就是哈希码，然后传到Integer.toHexString方法中，返回一个十六进制的数对应的字符串。具体过程：对象在堆中分配了地址，将地址进行哈希操作，转成哈希码，再通过方法转为十六进制的字符串。可以理解为返回一个地址，但是返回出的值的可读性不好，我们想知道对象里具体的内容，而不是十六进制的地址，所以我们对这个方法不满意，要对方法进行重写。比如：public String toString{    retrun “这是一个Student对象，这个对象的名字是：”+name+”，年龄是：”+age+”，身高是：”+height;}基本上我们都要进行重写，可以用IDEA的快捷键：alt+insert然后选toString()。\nequals()方法boolean flag = p1.equals(p2);作用：比较两个对象是否一致。== 对于基本数据类型来说，比较的是数值是否相当，对于引用数据类型来说，比较的是两者的地址是否相等。equals方法是提供一个对对象的具体内容是否相等的一个方式，对象内容就是只属性，分类Object类就是==，没有什么具体用法，一般要对这个方法进行重写。比如：public boolean equals(Object obj){    //要将obj转为Phone类型,Phone是自己写的类    Phone other = (Phone)obj;    if(this.getBrand()==other.getBrand()&amp;&amp;this.getPrice()==other.getPrice()){        retrun ture;    }else{        retrun false;    }}在其他类里调用重写的eqalus方法时候，可以用instanceof运算符判断新的类是否为旧类的实体对象，是的话返回true，不是的话返回false。可以用IDEA的快捷键alt+insert，重写eqals方法。\n","categories":["Java"],"tags":["类"]},{"title":"成员内部类","url":"/2022/03/13/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/","content":"成员内部类一个类的内部的类叫内部类\n类的组成类：属性，方法，构造器，代码块（普通块，静态块，构造块，同步块），内部类内部类：成员内部类和局部内部类（位置：方法块，块内，构造器内）内部类可以有属性，方法，构造器等修饰符可以是pravitae,default,protect,public,abstract内部类可以访问外部类的内容外部类想要访问内部类的东西需要创建对象来进行调用\n","categories":["Java"],"tags":["内部类"]},{"title":"面向对象项目练习","url":"/2022/03/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/","content":"项目1（购买披萨系统）项目需求\n代码public class Pizza { //父类披萨    private String name;    private int price;    private int size;\npublic Pizza() &#123;\n&#125;\n\npublic Pizza(String name, int price, int size) &#123;\n    this.name = name;\n    this.price = price;\n    this.size = size;\n&#125;\n\npublic String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n\npublic int getPrice() &#123;\n    return price;\n&#125;\n\npublic void setPrice(int price) &#123;\n    this.price = price;\n&#125;\n\npublic int getSize() &#123;\n    return size;\n&#125;\n\npublic void setSize(int size) &#123;\n    this.size = size;\n&#125;\n\n@Override\npublic String toString() &#123;\n    return &quot;披萨的名字：&quot; + name + &quot;\\n价格：&quot; + price +&quot;元&quot;+ &quot;\\n大小：&quot; + size+&quot;寸&quot;;\n&#125;\n\n}public class Bacon extends Pizza{ //培根比萨    private int weight;\npublic Bacon() &#123;\n&#125;\n\npublic Bacon(String name, int price, int size, int weight) &#123;\n    super(name, price, size);\n    this.weight = weight;\n&#125;\n\npublic int getWeight() &#123;\n    return weight;\n&#125;\n\npublic void setWeight(int weight) &#123;\n    this.weight = weight;\n&#125;\n\n@Override\npublic String toString() &#123;\n    return super.toString()+ &quot;\\n培根克数：&quot; + weight+&quot;克&quot;;\n&#125;\n\n}public class Fruit extends Pizza{ //水果披萨    private String burdening;\npublic Fruit() &#123;\n&#125;\n\npublic Fruit(String name, int price, int size, String burdening) &#123;\n    super(name, price, size);\n    this.burdening = burdening;\n&#125;\n\npublic String getBurdening() &#123;\n    return burdening;\n&#125;\n\npublic void setBurdening(String burdening) &#123;\n    this.burdening = burdening;\n&#125;\n\n@Override\npublic String toString() &#123;\n    return super.toString()+&quot;\\n配料水果：&quot; + burdening ;\n&#125;\n\n}public class PizzaFactory { //披萨工厂    public static Pizza getPizza(int choice){        Pizza pizza = null;        Scanner sc = new Scanner(System.in);        switch (choice){            case 1:{                System.out.println(“请输入需要的培根克数：”);                int weight = sc.nextInt();                System.out.println(“请输入披萨的价格：”);                int price = sc.nextInt();                System.out.println(“请输入披萨的大小：”);                int size = sc.nextInt();                Bacon bp = new Bacon(“培根披萨”,price,size,weight);                pizza = bp;            }            break;            case 2: {                System.out.println(“请输入需要的水果：”);                String burdening = sc.next();                System.out.println(“请输入披萨的价格：”);                int price = sc.nextInt();                System.out.println(“请输入披萨的大小：”);                int size = sc.nextInt();                Fruit fp = new Fruit(“水果披萨”,price,size,burdening);                pizza = fp;            }            break;        }        return pizza;    }}public class Main {    //这是一个main方法，是程序的入口    public static void main(String[] args) {        System.out.println(“请输入你想要购买额披萨：1.培根比萨 2.水果披萨”);        Scanner sc = new Scanner(System.in);        int choice = sc.nextInt();        Pizza pizza = PizzaFactory.getPizza(choice);        System.out.println(pizza.toString());    }}\n项目2（购买饮品）项目需求\n代码public class Drink { //父类饮料    private String name;    private int price;    private String cup ;    private String remark;//备注    private int num;\npublic Drink() &#123;\n&#125;\n\npublic Drink(String name, int price, String cup, String remark, int num) &#123;\n    this.name = name;\n    this.price = price;\n    this.cup = cup;\n    this.remark = remark;\n    this.num = num;\n&#125;\n\npublic String getName() &#123;\n    return name;\n&#125;\n\npublic void setName(String name) &#123;\n    this.name = name;\n&#125;\n\npublic int getPrice() &#123;\n    return price;\n&#125;\n\npublic void setPrice(int price) &#123;\n    this.price = price;\n&#125;\n\npublic String getCup() &#123;\n    return cup;\n&#125;\n\npublic void setCup(String cup) &#123;\n    this.cup = cup;\n&#125;\n\npublic String getRemark() &#123;\n    return remark;\n&#125;\n\npublic void setRemark(String remark) &#123;\n    this.remark = remark;\n&#125;\n\npublic int getNum() &#123;\n    return num;\n&#125;\n\npublic void setNum(int num) &#123;\n    this.num = num;\n&#125;\n\n@Override\npublic String toString() &#123;\n    return &quot;订单信息：您购买了：&quot;+name+&quot;：&quot;+remark+&quot;,购买的：&quot;+cup+&quot;，数量是：&quot;+num+&quot;，价格：&quot;+price*num+&quot;元&quot;;\n&#125;\n\n}\npublic class Cola extends Drink{ //可乐类\npublic Cola() &#123;\n&#125;\n\npublic Cola(String name, int price, String cup, String remark, int num) &#123;\n    super(name, price, cup, remark, num);\n&#125;\n\n}public class Coffee extends Drink{ //咖啡类\npublic Coffee() &#123;\n&#125;\n\npublic Coffee(String name, int price, String cup, String remark, int num) &#123;\n    super(name, price, cup, remark, num);\n&#125;\n\n}public class MilkyTea extends Drink{ //奶茶类\npublic MilkyTea() &#123;\n&#125;\n\npublic MilkyTea(String name, int price, String cup, String remark, int num) &#123;\n    super(name, price, cup, remark, num);\n&#125;\n\n}public class DrinkStore { //饮料商店（工厂）    public static Drink getDrink(int choice){        Drink drink = null;        Scanner sc = new Scanner(System.in);        switch (choice){            case 1:{                System.out.println(“请输入你需要的可乐信息：”+”\\n备注要可口可乐还是百事可乐，是否加冰”);                String remark = sc.next();                System.out.println(“选择:中杯 大杯 or 超大杯”);                String cup = sc.next();                System.out.println(“购买数量：”);                int num = sc.nextInt();                Cola cola = new Cola(“可乐”,3,cup,remark,num);                drink = cola;            }break;            case 2:{                System.out.println(“请输入你需要的咖啡信息：”+”\\n备注加糖、加奶、都不加，是否加冰”);                String remark = sc.next();                System.out.println(“选择:中杯 大杯 or 超大杯”);                String cup = sc.next();                System.out.println(“购买数量：”);                int num = sc.nextInt();                Coffee coffee = new Coffee(“咖啡”,5,cup,remark,num);                drink = coffee;            }break;            case 3:{                System.out.println(“请输入你需要的奶茶信息：”+”\\n备注加椰果、红豆还是布丁，是否加冰”);                String remark = sc.next();                System.out.println(“选择:中杯 大杯 or 超大杯”);                String cup = sc.next();                System.out.println(“购买数量：”);                int num = sc.nextInt();                MilkyTea milkyTea = new MilkyTea(“奶茶”,8,cup,remark,num);                drink = milkyTea;            }break;        }        return drink;    }}public class Main {    //这是一个main方法，是程序的入口    public static void main(String[] args) {        System.out.println(“请输入你想要购买的饮料：1.可乐 2. 咖啡 3.奶茶”);        Scanner sc = new Scanner(System.in);        int choice = sc.nextInt();        Drink drink = DrinkStore.getDrink(choice);        System.out.println(drink.toString());    }}\n","categories":["Java"],"tags":["项目"]},{"title":"Java中的异常","url":"/2021/12/23/%E5%BC%82%E5%B8%B8/","content":"异常异常：程序运行中，发生了不正常的现象，阻止了程序的运行，称之为异常。\n异常怎么看第一行代表出现的什么异常，最后一行是代码出错的位置，在哪个类第几行。\n处理异常的方式通过if-else解决异常比如：if(sc.hasNextInt){ //如果输入的是一个int型类型\n}优点：用法简单缺点：代码臃肿，可读性差，业务代码和处理异常的代码混合在一起，需要花费大量时间维护代码，很难堵住所有漏洞\nJava中的异常处理机制异常三连：（try-catch-finally）try{    System.out.printf(“正常代码”);}catch(Exception ex){    System.out.printf(“对不起，程序出现异常。”);}    System.out.printf(“异常后的代码可以正常运行”);    原理：把可能出现异常的代码放入try中，然后将异常代码进行输出，被catch后面的（）中的异常对象接收，接收之后，执行catch后面的{}中的代码，然后后面的代码继续正常运行。    try中没有异常，catch中代码不运行。    try中有异常，catch进行捕获。    如果catch中异常类型和你出的异常类型匹配的话，走catch中的代码，进行捕获。    如果catch中异常类型和你出的异常类型不匹配的话，不走catch中的代码，则没有捕获成功，程序相当于出现了异常，中断了，则后续代码不执行。    注意：如果try中出现异常，catch也捕获成功了，则try异常后面的代码不运行；try-catch后面的代码正常运行。catch中的处理方式：1.catch中什么都不写，空代码块2.自定义输出内容，如：程序出现异常3.调用toString方法，ex或者ex.toString()显示异常的类名（全限定路径）4.用ex.getMessage()，显示异常描述的信息对应的字符串，如果没有显示null5.用ex.printStackTrace(),显示异常的堆栈信息，就是将异常信息捕获后，在控制台显示出来，后面代码正常运行，比较常用6.抛出异常，throw ex在什么情况下，try-catch后面的代码不执行：throw抛出异常，catch中没有正常进行捕获，在try中遇到returnfinally就是为了防止这种情况出现，让异常之后的代码必须正常运行，比如：try{    System.out.printf(“正常代码”);}catch(Exception ex){    System.out.printf(“对不起，程序出现异常。”);}finally{    System.out.printf(“finally中代码必须正常运行”);}异常三连的运行顺序：限制性finally，在执行return。一般什么代码放在finally中：关闭数据库，关闭IO数据流，关闭socket资源有一个代码可以让finally中代码不执行：System.exit(0);//终止当前的虚拟机执行\n多重catch捕获异常catch可以写多个，比如：\ntry{    System.out.printf(“正常代码”);}catch(InputMismatchException ex){    System.out.printf(“对不起，你录入的数据不是int型数据”);}catch（ArithmeticException ex）{    System.out.printf(“对不起，除数不能为0”);}catch（Exception ex）{    System.out.printf(“对不起，程序出现异常。”);}一旦执行了一条catch语句后，后面的catch则不执行，在安排catch顺序时，一般先写子类异常，后写父类异常。在jdk1.7以后可以用或符号进行连接，如：catch（ArithmeticException ex ｜ InputMismatchException ex）{\n}\n异常的分层，层次结构运行时异常：public class Test5 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //运行时异常：        int[] arr = {1,2,3};        System.out.println(arr.length);        /int[] arr2 = null;        System.out.println(arr2.length);/        System.out.println(arr[10]);    }}检查异常：处理方式1：try-catch嵌套try-catchpublic class Test6 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //检查异常：        try {            try {                Class.forName(“com.msb.test01.Test”).newInstance();            } catch (InstantiationException e) {                e.printStackTrace();            } catch (IllegalAccessException e) {                e.printStackTrace();            }        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}处理方式2：多重catchpublic class Test6 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //检查异常：        try {            Class.forName(“com.msb.test01.Test”).newInstance();        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {            e.printStackTrace();        }    }}处理方式3：throwspublic class Test6 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {        //检查异常：        Class.forName(“com.msb.test01.Test”).newInstance();    }}\n异常分层总结！\nthrow和throwsthrow和throws的区别：（1）位置不同：throw：方法内部throws: 方法的签名处，方法的声明处\n（2）内容不同：throw+异常对象（检查异常，运行时异常）throws+异常的类型（可以多个类型，用，拼接）\n（3）作用不同：throw：异常出现的源头，制造异常。throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理：要么自己处理要么再继续向外抛出异常代码：public class Test7 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) throws Exception {        //实现一个功能：两个数相除，当除数为0的时候，程序出现异常。        /try {            devide();        } catch (Exception e) {            e.printStackTrace();        }/        devide();    }    public static void devide() throws Exception {        Scanner sc = new Scanner(System.in);        System.out.println(“请录入第一个数：”);        int num1 = sc.nextInt();        System.out.println(“请录入第二个数：”);        int num2 = sc.nextInt();        if(num2 == 0 ){//除数为0 ，制造异常。            //制造运行时异常：            /throw new RuntimeException();/            //制造检查异常：            /try {                throw new Exception();            } catch (Exception e) {                e.printStackTrace();            }/            throw new Exception();        }else{            System.out.println(“商：”+num1/num2);        }    }}\n重载和重写异常的区别！1.重载：public class Demo {    public void a() throws Exception{    }    public void a(int age) throws ArithmeticException{    }}2.重写public class Person{    public void eat()throws RuntimeException{        System.out.printf(“父类方法”);    }}public class Student extends Person{    public void eat()throws Exception{        System.out.printf(“子类方法”);    }}子类应该&lt;=父类\n自定义异常自定义的异常可以继承：运行时异常public class MyException extends RuntimeException {\nstatic final long serialVersionUID = -70348971907L;\n\npublic MyException()&#123;\n&#125;\npublic MyException(String msg)&#123;\n    super(msg);\n&#125;\n\n}\n也可以继承检查异常：public class MyException extends Exception {    static final long serialVersionUID = -70348971907L;    public MyException(){    }    public MyException(String msg){        super(msg);    }}如果继承的是运行时异常，那么在使用的时候无需额外处理如果继承的是检查异常，那么使用的时候需要try-catch捕获或者throws向上抛\n","categories":["Java"],"tags":["异常"]},{"title":"Java中的常用类","url":"/2021/12/23/%E5%B8%B8%E7%94%A8%E7%B1%BB/","content":"包装类\n什么是包装类：以前定义变量，经常使用基本数据类型，对于基本数据类型来说，它就是一个数，加点属性，加点方法，加点构造器，将基本数据类型对应进行了一个封装，产生了一个新的类，—》包装类。int,byte…..—&gt;基本数据类型包装类—&gt;引用数据类型\n\n对应关系：基本数据类型          对应的包装类                继承关系byte                          Byte                           —》Number—》Objectshort                         Short                         —》Number—》Objectint                             Integer                      —》Number—》Objectlong                          Long                          —》Number—》Objectfloat                          Float                          —》Number—》Objectdouble                      Double                      —》Number—》Objectchar                          Character                  Objectboolean                    Boolean                    Object\n\n已经有基本数据类型了，为什么要封装为包装类？（1）java语言 面向对象的语言，最擅长的操作各种各样的类。（2）以前学习装数据的—》数组，int[]  String[]  double[]   Student[]  以后学习的装数据的—》集合，有一个特点，只能装引用数据类型的数据\n\n\n4.不是有了包装类以后就不用基本数据类型。\n日期相关类java.util.Datepublic class Test {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //java.util.Date:        Date d = new Date();        System.out.println(d);        System.out.println(d.toString());        System.out.println(d.toGMTString());//过期方法，过时方法，废弃方法。        System.out.println(d.toLocaleString());        System.out.println(d.getYear());//120+1900=2020        System.out.println(d.getMonth());//5 :返回的值在 0 和 11 之间，值 0 表示 1 月。        //返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。        System.out.println(d.getTime());//1592055964263        System.out.println(System.currentTimeMillis());        /*        （1）疑问：以后获取时间差用：getTime()还是currentTimeMillis()        答案：currentTimeMillis()–》因为这个方法是静态的，可以类名.方法名直接调用        （2）public static native long currentTimeMillis();        本地方法        为什么没有方法体？因为这个方法的具体实现不是通过java写的。        （3）这个方法的作用：        一般会去衡量一些算法所用的时间         */        long startTime = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++) {            System.out.println(i);        }        long endTime = System.currentTimeMillis();        System.out.println(endTime-startTime);    }}\njava.sql.Datepublic class Test02 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //java.sql.Date:        Date d = new Date(1592055964263L);        System.out.println(d);        /*        (1)java.sql.Date和java.util.Date的区别：        java.util.Date：年月日  时分秒        java.sql.Date：年月日        (2)java.sql.Date和java.util.Date的联系：        java.sql.Date(子类) extends java.util.Date （父类）         /        //java.sql.Date和java.util.Date相互转换：        //【1】util—&gt;sql:        java.util.Date date = new Date(1592055964263L);//创建util.Date的对象        //方式1：向下转型        Date date1 = (Date) date;        /        父类：Animal 子类：Dog        Animal an = new Dog();        Dog d = (Dog)an;         */        //方式2：利用构造器        Date date2 = new Date(date.getTime());        //【2】sql–&gt;util:        java.util.Date date3 = d;        //[3]String—&gt;sql.Date:        Date date4 =  Date.valueOf(“2019-3-8”);    }}\nString—》java.util.Date 类型转换分解：（1）String—&gt;java.sql.Date（2）java.sql.Date—&gt;java.util.Datepublic class Test04 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //（1）String—&gt;java.sql.Date        java.sql.Date date = java.sql.Date.valueOf(“2015-9-24”);        //（2）java.sql.Date—&gt;java.util.Date        java.util.Date date2 = date;        System.out.println(date2.toString());    }}上面的代码有局限性，字符串的格式只能是年-月-日拼接的形式，换成其它类型，就会出现异常：\n【2】引入新的类：SimpleDateFormat\npackage com.msb.test02;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/**\n\n@Auther: msb-zhaoss\n/public class Test05 {  //这是一个main方法，是程序的入口：  public static void main(String[] args) {  //日期转换：\n  //SimpleDateFormat(子类) extends DateFormat（父类是一个抽象类）\n  //格式化的标准已经定义好了：\n  DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n  //String---&gt;Date\n  try &#123;\n      Date d = df.parse(&quot;2019-4-6 12:23:54&quot;);\n      System.out.println(d);\n  &#125; catch (ParseException e) &#123;\n      e.printStackTrace();\n  &#125;\n  //Date---&gt;String\n  String format = df.format(new Date());\n  System.out.println(format);\n  Date date = new Date();\n  System.out.println(date.toString());\n  System.out.println(date.toGMTString());\n  System.out.println(date.toLocaleString());\n\n  }}日期格式：！Calenderimport java.util.Calendar;import java.util.GregorianCalendar;public class Test06 {  //这是一个main方法，是程序的入口：  public static void main(String[] args) {  //Calendar是一个抽象类，不可以直接创建对象\n  //GregorianCalendar()子类 extends Calendar（父类是一个抽象类）\n  Calendar cal = new GregorianCalendar();\n  Calendar cal2 = Calendar.getInstance();\n  System.out.println(cal);\n  //常用的方法：\n  // get方法，传入参数：Calendar中定义的常量\n  System.out.println(cal.get(Calendar.YEAR));\n  System.out.println(cal.get(Calendar.MONTH));\n  System.out.println(cal.get(Calendar.DATE));\n  System.out.println(cal.get(Calendar.DAY_OF_WEEK));\n  System.out.println(cal.getActualMaximum(Calendar.DATE));//获取当月日期的最大天数\n  System.out.println(cal.getActualMinimum(Calendar.DATE));//获取当月日期的最小天数\n  // set方法：可以改变Calendar中的内容\n  cal.set(Calendar.YEAR,1990);\n  cal.set(Calendar.MONTH,3);\n  cal.set(Calendar.DATE,16);\n  System.out.println(cal);\n  //String---&gt;Calendar:\n  //分解：\n  //String---&gt;java.sql.Date:\n  java.sql.Date date = java.sql.Date.valueOf(&quot;2020-4-5&quot;);\n  //java.sql.Date--&gt;Calendar:\n  cal.setTime(date);\n  System.out.println(cal);\n\n  }}练习import java.util.Calendar;import java.util.Scanner;public class Test08 {  //这是一个main方法，是程序的入口：  public static void main(String[] args) {  //录入日期的String：\n  Scanner sc = new Scanner(System.in);\n  System.out.print(&quot;请输入你想要查看的日期：（提示：请按照例如2012-5-6的格式书写）&quot;);\n  String strDate = sc.next();\n  /*System.out.println(strDate);*/\n  //String---&gt;Calendar:\n  //String--&gt;Date:\n  java.sql.Date date = java.sql.Date.valueOf(strDate);\n  //Date---&gt;Calendar:\n  Calendar cal = Calendar.getInstance();\n  cal.setTime(date);\n  //后续操作：\n  //星期提示：\n  System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六\\t&quot;);\n  //获取本月的最大天数：\n  int maxDay = cal.getActualMaximum(Calendar.DATE);\n  //获取当前日期中的日：\n  int nowDay = cal.get(Calendar.DATE);\n  //将日期调为本月的1号：\n  cal.set(Calendar.DATE,1);\n  //获取这个一号是本周的第几天：\n  int num = cal.get(Calendar.DAY_OF_WEEK);\n  /*System.out.println(num);*/\n  //前面空出来的天数为：\n  int day = num - 1;\n  //引入一个计数器：\n  int count = 0;//计数器最开始值为0\n  //在日期前将空格打印出来：\n  for (int i = 1; i &lt;= day; i++) &#123;\n      System.out.print(&quot;\\t&quot;);\n  &#125;\n  //空出来的日子也要放入计数器：\n  count = count + day;\n  //遍历：从1号开始到maxDay号进行遍历：\n  for (int i = 1; i &lt;= maxDay ; i++) &#123;\n      if(i == nowDay)&#123;//如果遍历的i和当前日子一样的话，后面多拼一个*\n          System.out.print(i+&quot;*&quot;+&quot;\\t&quot;);\n      &#125;else&#123;\n          System.out.print(i+&quot;\\t&quot;);\n      &#125;\n      count++;//每在控制台输出一个数字，计数器做加1操作\n      if(count%7 == 0)&#123;//当计数器的个数是7的倍数的时候，就换行操作\n          System.out.println();\n      &#125;\n  &#125;\n\n  }}JDK1.8新增的日期APIJDK1.0中使用java.util.Date类  –》第一批日期时间API\n\nJDK1.1引入Calendar类   –》第二批日期时间API缺陷：可变性 : 像日期和时间这样的类应该是不可变的。偏移性 : Date中 的年份是从1900开始的，而月份都从0开始。格式化 : 格式化只对Date有用，Calendar则不行。\nJDK1.8新增日期时间API –》第三批日期时间API\n\njava.time.LocalDate;\njava.time.LocalDateTime;\njava.time.LocalTimepublic class Test09 { //这是一个main方法，是程序的入口： public static void main(String[] args) { //1.完成实例化：\n //方法1：now()--获取当前的日期，时间，日期+时间\n LocalDate localDate = LocalDate.now();\n System.out.println(localDate);\n LocalTime localTime = LocalTime.now();\n System.out.println(localTime);\n LocalDateTime localDateTime = LocalDateTime.now();\n System.out.println(localDateTime);\n //方法2：of()--设置指定的日期，时间，日期+时间\n LocalDate of = LocalDate.of(2010, 5, 6);\n System.out.println(of);\n LocalTime of1 = LocalTime.of(12, 35, 56);\n System.out.println(of1);\n LocalDateTime of2 = LocalDateTime.of(1890, 12, 23, 13, 24, 15);\n System.out.println(of2);\n //LocalDate,LocalTime用的不如LocalDateTime多\n //下面讲解用LocalDateTime：\n //一些列常用的get***\n System.out.println(localDateTime.getYear());//2020\n System.out.println(localDateTime.getMonth());//JUNE\n System.out.println(localDateTime.getMonthValue());//6\n System.out.println(localDateTime.getDayOfMonth());//14\n System.out.println(localDateTime.getDayOfWeek());//SUNDAY\n System.out.println(localDateTime.getHour());//22\n System.out.println(localDateTime.getMinute());//22\n System.out.println(localDateTime.getSecond());//6\n //不是set方法，叫with\n //体会：不可变性\n LocalDateTime localDateTime2 = localDateTime.withMonth(8);\n System.out.println(localDateTime);\n System.out.println(localDateTime2);\n //提供了加减的操作：\n //加：\n LocalDateTime localDateTime1 = localDateTime.plusMonths(4);\n System.out.println(localDateTime);\n System.out.println(localDateTime1);\n //减：\n LocalDateTime localDateTime3 = localDateTime.minusMonths(5);\n System.out.println(localDateTime);\n System.out.println(localDateTime3);\n\n }}\njava.time.format.DateTimeFormatter;\njava.time.format.FormatStyle;public class Test10 { //这是一个main方法，是程序的入口： public static void main(String[] args) { //格式化类：DateTimeFormatter\n //方式一:预定义的标准格式。如: ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;IS0_LOCAL_TIME\n DateTimeFormatter df1 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n //df1就可以帮我们完成LocalDateTime和String之间的相互转换：\n //LocalDateTime--&gt;String:\n LocalDateTime now = LocalDateTime.now();\n String str = df1.format(now);\n System.out.println(str);//2020-06-15T15:02:51.29\n //String---&gt;LocalDateTime\n TemporalAccessor parse = df1.parse(&quot;2020-06-15T15:02:51.29&quot;);\n System.out.println(parse);\n //方式二:本地化相关的格式。如: oflocalizedDateTime()\n //参数：FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT\n //FormatStyle.LONG :2020年6月15日 下午03时17分13秒\n //FormatStyle.MEDIUM: 2020-6-15 15:17:42\n //FormatStyle.SHORT:20-6-15 下午3:18\n DateTimeFormatter df2 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);\n //LocalDateTime--&gt;String:\n LocalDateTime now1 = LocalDateTime.now();\n String str2 = df2.format(now1);\n System.out.println(str2);\n //String---&gt;LocalDateTime\n TemporalAccessor parse1 = df2.parse(&quot;20-6-15 下午3:18&quot;);\n System.out.println(parse1);\n //方式三: 自定义的格式。如: ofPattern( &quot;yyyy-MM-dd hh:mm:ss&quot;) ---》重点，以后常用\n DateTimeFormatter df3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n //LocalDateTime--&gt;String:\n LocalDateTime now2 = LocalDateTime.now();\n String format = df3.format(now2);\n System.out.println(format);//2020-06-15 03:22:03\n //String---&gt;LocalDateTime\n TemporalAccessor parse2 = df3.parse(&quot;2020-06-15 03:22:03&quot;);\n System.out.println(parse2);\n\n }}Math类\n直接使用，无需导包：\nfinal修饰类，这个类不能被继承：\n构造器私有化，不能创建Math类的对象：不能：Math m = new Math();\nMath内部的所有的属性，方法都被static修饰：类名.直接调用，无需创建对象：\n常用方法：\n\npackage com.msb.test03;public class Test01 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //常用属性：        System.out.println(Math.PI);        //常用方法：        System.out.println(“随机数：”+Math.random());//[0.0,1.0)        System.out.println(“绝对值：”+Math.abs(-80));        System.out.println(“向上取值：”+Math.ceil(9.1));        System.out.println(“向下取值：”+Math.floor(9.9));        System.out.println(“四舍五入：”+Math.round(3.5));        System.out.println(“取大的那个值：”+Math.max(3, 6));        System.out.println(“取小的那个值：”+Math.min(3, 6));    }}6. 静态导入：\npackage com.msb.test03;//静态导入：import static java.lang.Math.*;public class Test01 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //常用属性：        System.out.println(PI);        //常用方法：        System.out.println(“随机数：”+random());//[0.0,1.0)        System.out.println(“绝对值：”+abs(-80));        System.out.println(“向上取值：”+ceil(9.1));        System.out.println(“向下取值：”+floor(9.9));        System.out.println(“四舍五入：”+round(3.5));        System.out.println(“取大的那个值：”+max(3, 6));        System.out.println(“取小的那个值：”+min(3, 6));    }    //如果跟Math中方法重复了，那么会优先走本类中的方法（就近原则）    public static int random(){        return 100;    }}\nRandom类import java.util.Random;public class Test02 {    //这是一个main方法，是程序的入口：    public static void main(String[] args) {        //返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。        System.out.println(“随机数：”+Math.random());        //学习Random类        //（1）利用带参数的构造器创建对象：        Random r1 = new Random(System.currentTimeMillis());        int i = r1.nextInt();        System.out.println(i);        //（2）利用空参构造器创建对象：        Random r2 = new Random();//表面是在调用无参数构造器，实际底层还是调用了带参构造器        System.out.println(r2.nextInt(10));//在 0（包括）和指定值（不包括）之间均匀分布的 int 值。        System.out.println(r2.nextDouble());//在 0.0 和 1.0 之间均匀分布的 double 值。    }}\nString类1.直接使用，无需导包：2.String str = “abc”;“abc”就是String类下的一个具体的对象3.字符串是不可变的：？？？？4.这个String类不可以被继承，不能有子类：5.String底层是一个char类型的数组\n常用方法\n构造器：底层就是给对象底层的value数组进行赋值操作。\n\n //通过构造器来创建对象：        String s1 = new String();        String s2 = new String(“abc”);        String s3 = new String(new char[]{‘a’,’b’,’c’});2. 常用方法：String s4 = “abc”;        System.out.println(“字符串的长度为：”+s4.length());        String s5 = new SZtring(“abc”);        System.out.println(“字符串是否为空：”+s5.isEmpty());        System.out.println(“获取字符串的下标对应的字符为：”+s5.charAt(1));\nequals:\n    String s6 = new String(&quot;abc&quot;);\n    String s7 = new String(&quot;abc&quot;);\n    System.out.println(s6.equals(s7));\n\n\nString类实现了Comparable，里面有一个抽象方法叫compareTo，所以String中一定要对这个方法进行重写：4\nString s8 = new String(“abc”);        String s9 = new String(“abc”);        System.out.println(s8.compareTo(s9));\n\n字符串的截取： String s10 = &quot;abcdefhijk&quot;;\n System.out.println(s10.substring(3));\n System.out.println(s10.substring(3, 6));//[3,6)\n //字符串的合并/拼接操作：\n System.out.println(s10.concat(&quot;pppp&quot;));\n //字符串中的字符的替换：\n String s11 = &quot;abcdeahija&quot;;\n System.out.println(s11.replace(&#39;a&#39;, &#39;u&#39;));\n //按照指定的字符串进行分裂为数组的形式：\n String s12 = &quot;a-b-c-d-e-f&quot;;\n String[] strs = s12.split(&quot;-&quot;);\n System.out.println(Arrays.toString(strs));\n //转大小写的方法：\n String s13 = &quot;abc&quot;;\n System.out.println(s13.toUpperCase());\n System.out.println(s13.toUpperCase().toLowerCase());\n //去除收尾空格：\n String s14 = &quot;    a  b  c    &quot;;\n System.out.println(s14.trim());\n //toString()\n String s15 = &quot;abc&quot;;\n System.out.println(s15.toString());\n //转换为String类型：\n\nStringBuilder类StringBuilder类\n字符串的分类：（1）不可变字符串：String（2）可变字符串：StringBuilder，StringBuffer\n\n疑问：（1）可变不可变？？（2）本节课重点：StringBuilder   —–》√（3）StringBuilder和StringBuffer区别  ？？\n\nStringBuilder底层：非常重要的两个属性：\n\n对应内存分析：package com.msb.test05;public class Test01 { //这是一个main方法，是程序的入口： public static void main(String[] args) {\n //创建StringBuilder的对象：\n StringBuilder sb3 = new StringBuilder();\n //表面上调用StringBuilder的空构造器，实际底层是对value数组进行初始化，长度为16\n StringBuilder sb2 = new StringBuilder(3);\n //表面上调用StringBuilder的有参构造器，传入一个int类型的数，实际底层就是对value数组进行初始化，长度为你传入的数字\n StringBuilder sb = new StringBuilder(&quot;abc&quot;);\n System.out.println(sb.append(&quot;def&quot;).append(&quot;aaaaaaaa&quot;).append(&quot;bbb&quot;).append(&quot;ooooooo&quot;).toString());;//链式调用方式：return this\n\n }}\n解释可变和不可变字符串\nString—》不可变\n\nStringBuilder—》可变可变，在StringBuilder这个对象的地址不变的情况下，想把“abc”变成“abcdef”是可能的，直接追加即可public class Test02 { //这是一个main方法，是程序的入口： public static void main(String[] args) {\n StringBuilder sb = new StringBuilder();\n System.out.println(sb.append(&quot;abc&quot;)==sb.append(&quot;def&quot;));//true\n\n }}\n常用方法\nStringBuilder常用方法：package com.msb.test05;public class Test03 { //这是一个main方法，是程序的入口： public static void main(String[] args) {\n StringBuilder sb=new StringBuilder(&quot;nihaojavawodeshijie&quot;);\n //增\n sb.append(&quot;这是梦想&quot;);\n System.out.println(sb);//nihaojavawodeshijie这是梦想\n //删\n sb.delete(3, 6);//删除位置在[3,6)上的字符\n System.out.println(sb);//nihavawodeshijie这是梦想\n sb.deleteCharAt(16);//删除位置在16上的字符\n System.out.println(sb);//nihavawodeshijie是梦想\n //改--&gt;插入\n StringBuilder sb1=new StringBuilder(&quot;$23445980947&quot;);\n sb1.insert(3, &quot;,&quot;);//在下标为3的位置上插入 ,\n System.out.println(sb1);\n StringBuilder sb2=new StringBuilder(&quot;$2你好吗5980947&quot;);\n //改--&gt;替换\n sb2.replace(3, 5, &quot;我好累&quot;);//在下标[3,5)位置上插入字符串\n System.out.println(sb2);\n sb.setCharAt(3, &#39;!&#39;);\n System.out.println(sb);\n //查\n StringBuilder sb3=new StringBuilder(&quot;asdfa&quot;);\n for (int i = 0; i &lt; sb3.length(); i++) &#123;\n     System.out.print(sb3.charAt(i)+&quot;\\t&quot;);\n &#125;\n System.out.println();\n //截取\n String str=sb3.substring(2,4);//截取[2,4)返回的是一个新的String，对StringBuilder没有影响\n System.out.println(str);\n System.out.println(sb3);\n\n }}\n\nStringBuffer常用方法：public class Test03 { //这是一个main方法，是程序的入口： public static void main(String[] args) {\n StringBuffer sb=new StringBuffer(&quot;nihaojavawodeshijie&quot;);\n //增\n sb.append(&quot;这是梦想&quot;);\n System.out.println(sb);//nihaojavawodeshijie这是梦想\n //删\n sb.delete(3, 6);//删除位置在[3,6)上的字符\n System.out.println(sb);//nihavawodeshijie这是梦想\n sb.deleteCharAt(16);//删除位置在16上的字符\n System.out.println(sb);//nihavawodeshijie是梦想\n //改--&gt;插入\n StringBuilder sb1=new StringBuilder(&quot;$23445980947&quot;);\n sb1.insert(3, &quot;,&quot;);//在下标为3的位置上插入 ,\n System.out.println(sb1);\n StringBuilder sb2=new StringBuilder(&quot;$2你好吗5980947&quot;);\n //改--&gt;替换\n sb2.replace(3, 5, &quot;我好累&quot;);//在下标[3,5)位置上插入字符串\n System.out.println(sb2);\n sb.setCharAt(3, &#39;!&#39;);\n System.out.println(sb);\n //查\n StringBuilder sb3=new StringBuilder(&quot;asdfa&quot;);\n for (int i = 0; i &lt; sb3.length(); i++) &#123;\n     System.out.print(sb3.charAt(i)+&quot;\\t&quot;);\n &#125;\n System.out.println();\n //截取\n String str=sb3.substring(2,4);//截取[2,4)返回的是一个新的String，对StringBuilder没有影响\n System.out.println(str);\n System.out.println(sb3);\n\n }}\n面试题String、StringBuffer、StringBuilder区别与联系\n\nString类是不可变类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。\n\nStringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setChartAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String\n\nJDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder\n\n\n    StringBuilder:JDK1.5开始  效率高   线程不安全\n    StringBuffer:JDK1.0开始   效率低    线程安全\n","categories":["Java"],"tags":["常用类"]}]